package simulator

import (
	"appengine"
	"appengine/datastore"
	"appengine/user"
	"controllers"
	"controllers/utils"
	"lib/gorilla/mux"
	"models"
	"net/http"
	"strconv"
	"time"
)

// Returns simulations saved in the datastore
func BrowseHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method == "GET" {
		limit := 20
		simulations := make([]models.Simulation, 0, limit)

		c := appengine.NewContext(r)
		q := datastore.NewQuery("Simulation").Order("-Name").Limit(limit)
		keys, err := q.GetAll(c, &simulations)

		if err != nil {
			controllers.ErrorHandler(w, err.Error(), http.StatusInternalServerError)
			return
		}

		for i := 0; i < len(keys); i++ {
			simulations[i].Id = keys[i].IntID()
		}

		data := map[string]interface{}{
			"sims": simulations,
		}

		controllers.BaseHandler(w, r, "simulator/browse", data)
	}
}

// GET returns a new simulation which the current user is made owner of (if logged in)
// POST saves the simulation and redirects to simulator/{simulatorId}
func NewSandboxHandler(w http.ResponseWriter, r *http.Request) {
	c := appengine.NewContext(r)
	u := user.Current(c)
	var simulation models.Simulation

	simType := "sandbox"
	creationTime := time.Now()

	if r.Method == "GET" {
		// TODO: it would be nice if we didn't have to explicity call "time.Now()"
		if u != nil { // Logged In
			simulation = models.Simulation{Name: "", UserID: u.ID, Contents: "{}", Type: simType, CreationDate: creationTime, UpdatedDate: creationTime}
		} else { // Not Logged In
			simulation = models.Simulation{Name: "", UserID: "", Contents: "{}", Type: simType, CreationDate: creationTime, UpdatedDate: creationTime} // Is this necessary?
		}
	} else if r.Method == "POST" {
		// Create the simulation object
		simulation = models.Simulation{Name: r.FormValue("Name"), UserID: u.ID, Contents: r.FormValue("Contents"), Type: simType, CreationDate: creationTime, UpdatedDate: creationTime}

		// Give it a new incomplete key
		// Datastore will define a simulation id for us
		key := datastore.NewIncompleteKey(c, "Simulation", nil)

		// Put the simulation in the datastore and retrieve the now complete key in result
		result, err := datastore.Put(c, key, &simulation)

		if err != nil {
			controllers.ErrorHandler(w, "Could not save new simulation: "+err.Error(), http.StatusInternalServerError)
			return
		}

		// Grab the simulation id from the result key generated by the put
		// this should never fail....
		simId := strconv.FormatInt(result.IntID(), 10)

		// an AJAX Request would prevent a redirect..
		http.Redirect(w, r, "/simulator/sandbox/"+simId, http.StatusFound)

		return

	}

	// If it's a new simulation, you're the owner
	data := map[string]interface{}{
		"sim":     simulation,
		"isOwner": true,
	}

	controllers.BaseHandler(w, r, "simulator/sandbox", data)
}

// GET returns simulation as specified by the simulatorId passed in the url
// POST saves the simulation as specified by the simulatorId passed in the url
// Renders the simulator.html page
func EditSandboxHandler(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	simId := vars["simulatorId"]
	c := appengine.NewContext(r)
	u := user.Current(c)
	var simulation models.Simulation

	if r.Method == "GET" {

		// Existing Simulation
		id := utils.StringToInt64(simId)

		// Construct the simulations key
		k := datastore.NewKey(c, "Simulation", "", id, nil)

		if err := datastore.Get(c, k, &simulation); err != nil {
			controllers.ErrorHandler(w, "Simulation was not found: "+err.Error(), http.StatusInternalServerError)
			return
		}

	} else if r.Method == "POST" {

		// Posting existing simulation to datastore
		id := utils.StringToInt64(simId)

		// Construct the simulations key
		key := datastore.NewKey(c, "Simulation", "", id, nil)

		// We need to get the entity and update it instead
		// https://cloud.google.com/appengine/docs/go/datastore/entities#Go_Updating_an_entity
		err := datastore.Get(c, key, &simulation)

		simulation.Name = r.FormValue("Name")
		simulation.Contents = r.FormValue("Contents")
		simulation.UpdatedDate = time.Now()

		// Put the simulation in the datastore
		_, err = datastore.Put(c, key, &simulation)

		if err != nil {
			// Could not place the simulation in the datastore
			controllers.ErrorHandler(w, "Could not save existing simulation: "+err.Error(), http.StatusInternalServerError)
			return
		}

	}

	simulation.Id = utils.StringToInt64(simId)

	data := map[string]interface{}{
		"sim":     simulation,
		"isOwner": utils.IsOwner(simulation.UserID, u),
	}

	controllers.BaseHandler(w, r, "simulator/sandbox", data)
}

func NewKinematicsHandler(w http.ResponseWriter, r *http.Request) {
	controllers.BaseHandler(w, r, "simulator/kinematics", nil)
}
